# -*- coding: utf-8 -*-
"""Larger Alphabet.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1wX_1-fb8NWxgXSvfWNAUWaWbnsqz4Rr2
"""

def fitness(chromosome, numberDigits, target):
    currentScore = 0.0

    # Difference between target digit and chrom digit
    difference = 0

    # fitness penalty
    fitnessPenalty = 0.3

    for i in range(numberDigits):
        # The greater the distance between values, the worse the fitness
        difference = abs(int(chromosome[i]) - int(target[i]))
        currentScore += 1 - (fitnessPenalty * difference)

    return currentScore

def mutate(chromosome, mutationRate, numberDigits):
    # Increment or decrement 1 random digit of chromosome
    # (if mutation is triggered)
    if rand() < mutationRate:
        index = randint(0, numberDigits)

        # Get digit at chosen index
        originalDigit = int(chromosome[index])

        # 50/50 chance of incrementing or decrementing
        if rand() <= 0.5:
            # Incrementing
            if originalDigit == 9:
                # Digit is 9. Overflow it back to 0
                newDigit = 0
            else:
                newDigit = originalDigit + 1
        else:
            # Decrementing
            if originalDigit == 0:
                # Digit is 0. Underflow it back to 9
                newDigit = 9
            else:
                newDigit = originalDigit - 1
        return (chromosome[:index] + str(newDigit) + chromosome[index+1:])

    return chromosome

def tournamentSelection(population, scores, numberPop, k=5):
    # Pick some random index in population
    bestChromosome = randint(0, numberPop)

    # Pick contending chromosomes randomly
    for chrom in randint(0, numberPop, 4):
        # Find best score in tournament round
        if scores[chrom] > scores[bestChromosome]:
            bestChromosome = chrom
            
    return population[bestChromosome]

# Crossover between two parents to create two children
def crossover(p1, p2, crossRate):
	c1, c2 = p1, p2

	# check crossover to occur
	if rand() < crossRate:
		# select crossover point that is not on the end of the string
		pt = randint(1, len(p1)-2)
  
		# perform crossover
		c1 = p1[:pt] + p2[pt:]
		c2 = p2[:pt] + p1[pt:]

	return [c1, c2]

def geneticAlgorithm(population, averages, numberDigits, numberIter, numberPop, crossRate, mutateRate, target):
    # Cycle through generations
    for gen in range(numberIter):
        p = []
        c = []

        # Calculate all fitness scores for population
        scores = [fitness(n, numberDigits, target) for n in population]

        averages.append(statistics.mean(scores))

        # Print scores of current generation
        bestIndex, bestScore = scores.index(max(scores)), max(scores)
        print(f'GENERATION {gen+1}')
        print(f'BEST ITEM: {population[bestIndex]}')
        print(f'ITEM SCORE: {bestScore}')
        print(f'AVERAGE SCORE: {averages[gen]}\n')

        # Find parent chromosomes of next generation via selection
        for i in range(numberPop):
            p.append(tournamentSelection(population, scores, numberPop))

        # Pair up chromosome with the one right after it
        for i in range(0, numberPop, 2):
            parent1, parent2 = p[i], p[i+1]

            # Perform crossover, mutate children and append to list
            for child in crossover(parent1, parent2, crossRate):
                child = mutate(child, mutateRate, numberDigits)
                c.append(child)

        # Replace current generation with children
        population = c

    return averages

def plot_averages(averages, totalIter):
    plt.plot(range(1, totalIter+1), averages)
    plt.title(f'Average fitness for {totalIter} '
              'generations (Target String)')
    plt.xlabel('Generation')
    plt.ylabel('Average fitness')
    plt.show()

import statistics
import matplotlib.pyplot as plt
from numpy.random import randint, rand, choice

def main():
    # number of iterations
    # sometimes 50 is more than enough
    # othertimes it isn't, can be justed accordingly
    numberIter = 50

    # number of digits
    numberDigits = 30

    # population
    numberPop = 100

    # crossover rate
    crossRate = 0.9

    # mutation rate
    mutateRate = 1.0 / float(numberDigits)

    # Current char set being used (0 - 9)
    zeroToNine = list('0123456789')

    # target string
    target = ''.join(choice(zeroToNine) for _ in range(numberDigits))

    # List tracking the average fitness of each generation
    averages = []

    # Max value of a bit string in the population
    maxValue = (1 << numberDigits) - 1

    # Array to hold the population
    population = []

    # Target of GA is a 30 bit string of 1s
    print(f'Target is {target}\n')

    # Generate initial generation of chromosomes
    for i in range(0, numberPop):
        population.append(''.join(choice(zeroToNine) for _ in range(numberDigits)))

    averages = geneticAlgorithm(population, averages, numberDigits, numberIter, numberPop, crossRate, mutateRate, target)
    plot_averages(averages, numberIter)

if __name__ == '__main__':
    main()