# -*- coding: utf-8 -*-
"""Knapsack Problem.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/17UGnxVA9UyqmmAyf3Tpiib5ovR_52ub_
"""

import statistics
import sys
import matplotlib.pyplot as plt
from numpy.random import randint, rand, choice
from numpy import set_printoptions, arange

# Values of all items
values = [825594, 1677009, 1676628, 1523970, 943972, 97426, 69666, 1296457,
          1679693, 1902996, 1844992, 1049289, 1252836, 1319836, 953277,
          2067538, 675367, 853655, 1826027, 65731, 901489, 577243, 466257,
          369261]

# Weights of all items
weights = [382745, 799601, 909247, 729069, 467902, 44328, 34610, 698150,
           823460, 903959, 853665, 551830, 610856, 670702, 488960, 951111,
           323046, 446298, 931161, 31385, 496951, 264724, 224916, 169684]

# Maximum weight that knapsack can hold
capacity = 6404180

def fitness(chromosome, numberItems):
    valueTotal = 0
    weightTotal = 0

    for i in range(numberItems):
        # Get the sum of all values and weights in knapsack
        valueTotal += values[i] * ((chromosome >> (numberItems - i - 1)) & 1)
        weightTotal += weights[i] * ((chromosome >> (numberItems - i - 1)) & 1)

    # When the weight is below capacity, use it as the fitness score
    if weightTotal <= capacity:
        return valueTotal

    # If weight exceeds capacity, give it a harsh fitness
    return (capacity - weightTotal)

def mutate(chromosome, mutateRate, numberItems):
    # If mutatation actually occurs, flip a random bit
    if rand() < mutateRate:
        # Using a random index position, add or remove an item
        if rand() < 0.5:
            randomIndex = randint(0, numberItems)
            return (chromosome ^ (1 << randomIndex))
        else:
            # List of items present in knapsack
            inKnapsack = [x for x in range(numberItems)
                     if ((chromosome >> (numberItems - x - 1)) & 1)]

            # List of items not present in knapsack
            notKnapsack = [x for x in range(numberItems) if x not in inKnapsack]

            # A random item is remove, another random item is added
            removeItem = choice(inKnapsack)
            addItem = choice(notKnapsack)

            # Now we replace the items
            chromosome = (chromosome ^ (1 << (numberItems - removeItem - 1)))
            chromosome = (chromosome ^ (1 << (numberItems - addItem - 1)))
            
    return chromosome

def tournament_selection(population, scores, numberPop, round=3):
    # Pick some random index in population
    bestChromosome = randint(0, numberPop)

    # Pick contending chromosomes randomly
    for chromosome in randint(0, numberPop, round-1):
        # Find best score in tournament round
        if scores[chromosome] > scores[bestChromosome]:
            bestChromosome = chromosome
    return population[bestChromosome]

# Crossover between two parents to create two children
def crossover(p1, p2, crossRate, numberItems):
    # Children are copies of their respective parents
    c1, c2 = p1, p2

    # Randomly decide if crossover happens based on crossover_rate
    if rand() < crossRate:
        # i is the index where the crossover will happen between parents
        i = randint(1, numberItems-1)

        # beforeI captures first i bits of binary
        # afterI captures the rest of the bits
        beforeI = ((1 << i) - 1) << (numberItems - i)
        afterI = (1 << (numberItems - i)) - 1

        # First child is 
        c1 = (p1 & beforeI) | (p2 & afterI)

        # child_2 is the first i bits of parent_2. The rest are from parent_1
        c2 = (p2 & beforeI) | (p1 & afterI)

    return c1, c2

def geneticAlgorithm(population, averages, bestFitness, numberIter, numberPop, numberItems, crossRate, mutateRate):
    bestKnapsack = 0

    for gen in range(numberIter):
        parents = []
        children = []

        # Calculate all fitness scores for population
        scores = [fitness(n, numberItems) for n in population]

        averages.append(statistics.mean(scores))

        # Print scores of current generation
        bestIndex, bestScore = scores.index(max(scores)), max(scores)
        bestFitness.append(bestScore)
        if bestScore > fitness(bestKnapsack, numberItems):
            bestKnapsack = population[bestIndex]
        print(f'GENERATION {gen+1}')
        print(f'BEST ITEM: {population[bestIndex]:024b}')
        print(f'ITEM SCORE: {bestScore}')
        print(f'AVERAGE SCORE: {averages[gen]}\n')

        # Find parent chromosomes of next generation via selection
        for i in range(numberPop):
            parents.append(tournament_selection(population, scores, numberPop))

        # Pair up chromosome with the one right after it
        for i in range(0, numberPop, 2):
            p1, p2 = parents[i], parents[i+1]

            # Perform crossover, mutate children and append to list
            for child in crossover(p1, p2, crossRate, numberItems):
                child = mutate(child, mutateRate, numberItems)
                children.append(child)

        # Replace current generation with children
        population = children
    return bestKnapsack, fitness(bestKnapsack, numberItems)

def plot_averages(averages, bestFitness, total_iter):
    plt.plot(range(1, total_iter+1), averages)
    plt.plot(range(1, total_iter+1), bestFitness)
    plt.title(f'Average & best fitness for {total_iter} '
              'generations')
    plt.xlabel('Generation')
    plt.ylabel('Average fitness')
    plt.show()

def main():
    # number of iterations
    numberIter = 10

    # population
    numberPop = 100

     # Number of items and length of bitstrings
    numberItems = len(values)

    # crossover rate
    crossRate = 0.5

    # mutation rate
    mutateRate = 1.0 / float(30)

    # List tracking the average fitness of each generation
    averages = []

    # list tracking the best fitness of each generation
    bestFitness = []

    # Max value of a bit string in the population
    maxValue = (1 << numberItems) - 1

    # Array to hold the population
    population = []

    # Generate initial generation of chromosomes
    for i in range(0, numberPop):
        population.append(randint(0, maxValue+1))

    set_printoptions(threshold=sys.maxsize)
    print(population)
    #print('\n'.join('{}: {}'.format(*k) for k in enumerate(population)))
    print('')

    results = geneticAlgorithm(population, averages, bestFitness, numberIter, numberPop, numberItems, crossRate, mutateRate)
    print(f'BEST KNAPSACK FOUND: {results[0]:024b}')
    print(f'BEST SCORE: {results[1]}')
  
    plot_averages(averages, bestFitness, numberIter)

if __name__ == '__main__':
    main()